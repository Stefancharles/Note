## volatile
------
### 作用
简单地说就是防止编译器对代码进行优化。比如如下程序：
```c++
XBYTE[2]=0x55;
XBYTE[2]=0x56;
XBYTE[2]=0x57;
XBYTE[2]=0x58;
```
对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有XBYTE[2]=0x58（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，则编译器会逐一地进行编译并产生相应的机器代码（产生四条代码）。
###  问题
* 一个参数既可以是const还可以是volatile吗？解释为什么。

* 一个指针可以是volatile 吗？解释为什么。

* 下面的函数被用来计算某个整数的平方，它能实现预期设计目标吗？如果不能，试回答存在什么问题：
```c
int square(volatile int *ptr)
{
    return ((*ptr) * (*ptr));
}
```
### 答案
* 是的。一个例子是只读的**状态寄存器**。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

* 是的。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。

* 这段代码的目的是用来返指针 * ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
```c
int square(volatile int* &ptr)//这里参数应该申明为引用，不然函数体里只会使用副本，外部没法更改
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a*b;
}
```
由于*ptr的值可能在两次取值语句之间发生改变，因此a和b可能是不同的。结果，这段代码可能返回的不是所期望的平方值！正确的代码如下：
```c
long square(volatile int*ptr)
{
    int a;
    a = *ptr;
    return a*a;
}
```